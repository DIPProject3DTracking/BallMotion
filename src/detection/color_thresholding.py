from typing import List, Union

import cv2
import numpy as np


class ColorSegmenter:
    def __init__(
        self,
        base_color: List[int],
        rel_tol: List[float],
        morph_ksize=3,
        blur_ksize=11,
        blur_sigma=3,
    ):
        """Class for tracking a color in HSV space and generating a binary image.
        The binary image is generated by thresholding the HSV image and performing an opening operation.

        Args:
            base_color (List[int]): color to track in BGR (0-180, 0-255, 0-255)
            rel_tol (List[float]): relative tolerances that defines the upper and lower bounds of the HSV color range
            morph_ksize (int, optional): size of the kernel which is used for the opening. Defaults to 5.
        """
        self.blur_ksize = blur_ksize
        self.blur_sigma = blur_sigma

        rel_tol = np.array(rel_tol, dtype=np.float32)
        hsv_color_range = np.array([255, 255, 255], dtype=np.uint8)
        self.lower_bound = np.clip(
            base_color - rel_tol * hsv_color_range, a_min=0, a_max=hsv_color_range
        ).astype(np.uint8)
        self.upper_boud = np.clip(
            base_color + rel_tol * hsv_color_range, a_min=0, a_max=hsv_color_range
        ).astype(np.uint8)
        print(self.lower_bound, self.upper_boud)

        # Structuring element for morphological operations
        self.structuring_element = cv2.getStructuringElement(
            cv2.MORPH_OPEN, (morph_ksize, morph_ksize)
        )
        self.structuring_element_dilate = cv2.getStructuringElement(
            cv2.MORPH_DILATE, (morph_ksize, morph_ksize)
        )

    def adaptive_thresholding(self, frame):
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2LAB)

        # Perform histogram equalization on the V channel to improve contrast
        hsv_frame[:, :, 0] = cv2.equalizeHist(hsv_frame[:, :, 0])

        # Apply gaussian blur (needed because the ball has spikes on its surface)
        hsv_frame = cv2.GaussianBlur(
            hsv_frame,
            ksize=(self.blur_ksize, self.blur_ksize),
            sigmaX=self.blur_sigma,
            sigmaY=self.blur_sigma,
        )
        if self.lower_bound.shape[0] == 2:
            print(self.lower_bound[0], self.upper_boud[0])
            print(self.lower_bound[1], self.upper_boud[1])
            mask1 = cv2.inRange(hsv_frame, self.lower_bound[0], self.upper_boud[0])
            mask2 = cv2.inRange(hsv_frame, self.lower_bound[1], self.upper_boud[1])

            binary_image = cv2.binary_or(mask1, mask2)
        else:
            binary_image = cv2.inRange(hsv_frame, self.lower_bound, self.upper_boud)

        # Perform opening
        binary_image = cv2.morphologyEx(
            binary_image, cv2.MORPH_OPEN, self.structuring_element, iterations=4
        )

        return binary_image

    def generate_bin_img(self):
        cap = cv2.VideoCapture(0)

        if not cap.isOpened():
            raise IOError("Cannot open webcam")

        while cv2.waitKey(1) & 0xFF != ord("q"):
            ret_succ, frame = cap.read()

            if not ret_succ:
                print("Could not read frame! Exiting ...")
                break

            binary_image = self.adaptive_thresholding(frame)
            cv2.imshow("Processed Frame", binary_image)

        cap.release()
        cv2.destroyWindow("Processed Frame")


if __name__ == "__main__":
    color_tracker = ColorSegmenter(base_color=[87, 192, 167], rel_tol=[0.7, 0.11, 0.1])
    color_tracker.generate_bin_img()
