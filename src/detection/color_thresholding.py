from typing import List, Union

import cv2
import numpy as np


class ColorTracker:
    def __init__(self, base_color: List[int], rel_tol, morph_ksize=5):
        """Class for tracking a color in HSV space and generating a binary image.
        The binary image is generated by thresholding the HSV image and performing an opening operation.

        Args:
            base_color (List[int]): color to track in HSV: (H in [0,360), S in [0, 1], V in [0, 1])
            rel_tol (_type_): relative tolerance that defines the upper and lower bounds
            morph_ksize (int, optional): size of the kernel which is used for the opening. Defaults to 5.
        """
        # base_color = np.array(base_color)
        # base_color[0] /= 2
        # base_color[1:] *= 255
        # base_color = base_color.astype(np.uint8)
        base_color = self.rgb_to_hsv(base_color)

        self.lower_bound, self.upper_boud = base_color * (1 - rel_tol), base_color * (
            1 + rel_tol
        )

        # Structuring element for morphological operations
        self.structuring_element = cv2.getStructuringElement(
            cv2.MORPH_ELLIPSE, (morph_ksize, morph_ksize)
        )

    def color_thresholding_and_open(self, frame):
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        binary_image = cv2.inRange(hsv_frame, self.lower_bound, self.upper_boud)

        # Perform opening
        binary_image = cv2.morphologyEx(
            binary_image, cv2.MORPH_OPEN, self.structuring_element, iterations=2
        )

        return binary_image

    def generate_bin_img(self):
        cap = cv2.VideoCapture(0)

        if not cap.isOpened():
            raise IOError("Cannot open webcam")

        while cv2.waitKey(10) & 0xFF != ord("q"):
            ret, frame = cap.read()

            if not ret:
                print("Could not read frame! Exiting ...")
                break

            binary_image = self.color_thresholding_and_open(frame)
            # cv2.imshow("Processed Frame", binary_image)
            self.predict(binary_image)

        cap.release()
        # cv2.destroyWindow("Processed Frame")
        cv2.destroyAllWindows()

    def rgb_to_hsv(self, rgb_list):
        # Convert the input list into a numpy array and reshape to a single pixel RGB image
        rgb_array = np.array(rgb_list, dtype=np.uint8).reshape(-1, 1, 3)
        hsv_array = cv2.cvtColor(rgb_array, cv2.COLOR_RGB2HSV)

        return hsv_array

    def predict(self, img):
        # Convert to grayscale.

        # Blur using 3 * 3 kernel.
        # gray_blurred = cv2.blur(gray, (3, 3))

        # Apply Hough transform on the blurred image.
        detected_circles = cv2.HoughCircles(
            img,
            cv2.HOUGH_GRADIENT,
            1,
            20,
            param1=100,
            param2=30,
            minRadius=20,
            maxRadius=500,
        )

        # Draw circles that are detected.
        # if detected_circles is not None:
        # Convert the circle parameters a, b and r to integers.
        if detected_circles is not None:
            detected_circles = np.uint16(np.around(detected_circles))
            for pt in detected_circles[0, :]:
                a, b, r = pt[0], pt[1], pt[2]

                # Draw the circumference of the circle.
                cv2.circle(img, (a, b), r, (0, 255, 0), 2)

                # Draw a small circle (of radius 1) to show the center.
                cv2.circle(img, (a, b), 1, (0, 0, 255), 3)
        cv2.imshow("Detected Circle", img)


if __name__ == "__main__":
    # 35 46 50
    color_tracker = ColorTracker(base_color=[79, 97, 35], rel_tol=0.4)
    color_tracker.generate_bin_img()
