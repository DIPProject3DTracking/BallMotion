from dataclasses import dataclass
from typing import List, Union

import cv2
import numpy as np


@dataclass
class Ellipse:
    def __init__(self, cnt, eccentricity_treshold=0.1):
        self.ellipse = cv2.fitEllipse(cnt)
        self.eccentricity = None
        self.eccentricity_treshold = eccentricity_treshold

    @property
    def center(self):
        return self.ellipse[0]

    @property
    def major_axis(self):
        return self.ellipse[1][0]

    @property
    def minor_axis(self):
        return self.ellipse[1][1]

    @property
    def angle(self):
        return self.ellipse[2]

    def get_eccentricity(self):
        if self.eccentricity is None:
            self.eccentricity = np.sqrt(1 - (self.major_axis / self.minor_axis) ** 2)
        return self.eccentricity

    def draw(self, binary_image):
        color_image = cv2.cvtColor(binary_image, cv2.COLOR_GRAY2BGR)
        cv2.ellipse(color_image, self.ellipse, (0, 255, 0), 2)
        return color_image


class ColorSegmenter:
    def __init__(
        self,
        base_color: List[int],
        rel_tol: List[float],
        morph_ksize=5,
        blur_ksize=11,
        blur_sigma=3,
    ):
        """Class for tracking a color in lab space and generating a binary image.
        The binary image is generated by thresholding the lab image and performing an opening operation.

        Args:
            base_color (List[int]): color to track in LAB (0-180, 0-255, 0-255)
            rel_tol (List[float]): relative tolerances that defines the upper and lower bounds of the lab color range
            morph_ksize (int, optional): size of the kernel which is used for the opening. Defaults to 5.
        """
        self.blur_ksize = blur_ksize
        self.blur_sigma = blur_sigma

        self.ellipses: List[Ellipse] = []

        rel_tol = np.array(rel_tol, dtype=np.float32)
        lab_color_range = np.array([255, 255, 255], dtype=np.uint8)
        self.lower_bound = np.clip(
            base_color - rel_tol * lab_color_range, a_min=0, a_max=lab_color_range
        ).astype(np.uint8)
        self.upper_boud = np.clip(
            base_color + rel_tol * lab_color_range, a_min=0, a_max=lab_color_range
        ).astype(np.uint8)

        # Structuring element for morphological operations
        self.structuring_element = cv2.getStructuringElement(
            cv2.MORPH_ELLIPSE, (morph_ksize, morph_ksize)
        )

    def apply_color_thresholding(self, frame):
        lab_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2LAB)

        # Perform histogram equalization on the V channel to improve contrast
        lab_frame[:, :, 0] = cv2.equalizeHist(lab_frame[:, :, 0])

        lab_frame = cv2.GaussianBlur(
            lab_frame,
            ksize=(self.blur_ksize, self.blur_ksize),
            sigmaX=self.blur_sigma,
            sigmaY=self.blur_sigma,
        )

        binary_image = cv2.inRange(lab_frame, self.lower_bound, self.upper_boud)

        # Perform opening
        binary_image = cv2.morphologyEx(
            binary_image, cv2.MORPH_CLOSE, self.structuring_element, iterations=4
        )

        return binary_image

    def calculate_roundness(self, binary_image):
        # https://opencv24-python-tutorials.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html
        # find external contours and store the endpoints
        contours, _ = cv2.findContours(
            binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        if not contours:
            return None
        # pick the largest contour if there are several binary blobs
        contour = max(contours, key=cv2.contourArea)
        if contour.shape[0] < 5:  # fitEllipse requires at least 5 landmarks
            return None
        # fit ellipse to the contour and get its properties
        detected_ellipse = Ellipse(contour)
        if detected_ellipse.minor_axis == 0:
            return None
        return detected_ellipse

    def generate_bin_img(self):
        cap = cv2.VideoCapture(0)

        if not cap.isOpened():
            raise IOError("Cannot open webcam")

        while cv2.waitKey(1) & 0xFF != ord("q"):
            ret_succ, frame = cap.read()

            if not ret_succ:
                print("Could not read frame! Exiting ...")
                break

            binary_image = self.apply_color_thresholding(frame)
            ellipse = self.calculate_roundness(binary_image)
            if ellipse is not None:
                print("Roundness:", ellipse.get_eccentricity())
                self.ellipses.append(ellipse)
                cv2.imshow("Processed Frame", ellipse.draw(binary_image))
            else:
                cv2.imshow("Processed Frame", binary_image)

        cap.release()
        cv2.destroyAllWindows()


if __name__ == "__main__":
    color_tracker = ColorSegmenter(base_color=[87, 192, 167], rel_tol=[0.7, 0.11, 0.1])
    color_tracker.generate_bin_img()
