from typing import List, Union

import cv2
import numpy as np


class ColorSegmenter:
    def __init__(
        self,
        base_color: List[int],
        rel_tol: List[float],
        morph_ksize=3,
        blur_ksize=17,
        blur_sigma=8,
    ):
        """Class for tracking a color in HSV space and generating a binary image.
        The binary image is generated by thresholding the HSV image and performing an opening operation.

        Args:
            base_color (List[int]): color to track in BGR (0-180, 0-255, 0-255)
            rel_tol (List[float]): relative tolerances that defines the upper and lower bounds of the HSV color range
            morph_ksize (int, optional): size of the kernel which is used for the opening. Defaults to 5.
        """
        self.blur_ksize = blur_ksize
        self.blur_sigma = blur_sigma

        rel_tol = np.array(rel_tol, dtype=np.float32)
        hsv_color_range = np.array([180, 255, 255], dtype=np.uint8)
        self.lower_bound = np.clip(
            base_color - rel_tol * hsv_color_range, a_min=0, a_max=hsv_color_range
        ).astype(np.uint8)
        self.upper_boud = np.clip(
            base_color + rel_tol * hsv_color_range, a_min=0, a_max=hsv_color_range
        ).astype(np.uint8)
        print(self.lower_bound, self.upper_boud)

        # Structuring element for morphological operations
        self.structuring_element = cv2.getStructuringElement(
            cv2.MORPH_OPEN, (morph_ksize, morph_ksize)
        )
        self.structuring_element_dilate = cv2.getStructuringElement(
            cv2.MORPH_DILATE, (morph_ksize, morph_ksize)
        )

    def adaptive_thresholding(self, frame):
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # Perform histogram equalization on the V channel to improve contrast
        hsv_frame[:, :, 2] = cv2.equalizeHist(hsv_frame[:, :, 2])

        # Apply gaussian blur (needed because the ball has spikes on its surface)
        hsv_frame = cv2.GaussianBlur(
            hsv_frame,
            ksize=(self.blur_ksize, self.blur_ksize),
            sigmaX=self.blur_sigma,
            sigmaY=self.blur_sigma,
        )

        binary_image = cv2.inRange(hsv_frame, self.lower_bound, self.upper_boud)

        # Perform opening
        binary_image = cv2.morphologyEx(
            binary_image, cv2.MORPH_OPEN, self.structuring_element, iterations=3
        )

        # binary_image = cv2.GaussianBlur(
        #     binary_image,
        #     ksize=(3, 3),
        #     sigmaX=3,
        #     sigmaY=3,
        # )

        # # Perform dilation
        # binary_image = cv2.dilate(
        #     binary_image, self.structuring_element_dilate, iterations=3
        # )

        return binary_image

    def generate_bin_img(self):
        cap = cv2.VideoCapture(0)

        if not cap.isOpened():
            raise IOError("Cannot open webcam")

        while cv2.waitKey(1) & 0xFF != ord("q"):
            ret_succ, frame = cap.read()

            if not ret_succ:
                print("Could not read frame! Exiting ...")
                break

            binary_image = self.adaptive_thresholding(frame)
            cv2.imshow("Processed Frame", binary_image)

        cap.release()
        cv2.destroyWindow("Processed Frame")


if __name__ == "__main__":
    """
    Median (HSV): [106.         250.87037037  29.66666667]; (BGR): [29 14  1])
    Std: [ 2.6232788  25.87845015 37.23547614]
    """
    color_tracker = ColorSegmenter(base_color=[106, 251, 30], rel_tol=[0.03, 0.15, 0.6])
    color_tracker.generate_bin_img()
